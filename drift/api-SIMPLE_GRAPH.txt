note
	description: "Generic graph data structure with adjacency list representation"
	author: "Larry Rix"
	date: "$Date$"
	revision: "$Revision$"

class interface
	SIMPLE_GRAPH [G -> detachable separate ANY]

create 
	make
			-- Create undirected graph.
		ensure
			not_directed: not is_directed
			empty: is_empty

	make_directed
			-- Create directed graph.
		ensure
			directed: is_directed
			empty: is_empty

feature -- Access

	all_edges: ARRAYED_LIST [TUPLE [from_node: INTEGER_32; to_node: INTEGER_32; weight: REAL_64]]
			-- List of all edges as tuples.

	all_nodes: ARRAYED_LIST [INTEGER_32]
			-- List of all node IDs.

	edge_count: INTEGER_32
			-- Number of edges in graph.

	edge_weight (a_from, a_to: INTEGER_32): REAL_64
			-- Weight of edge from `a_from` to `a_to`.
		require
			has_edge: has_edge (a_from, a_to)

	generating_type: TYPE [detachable SIMPLE_GRAPH [G]]
			-- Type of current object
			-- (type of which it is a direct instance)
			-- (from ANY)
		ensure -- from ANY
			generating_type_not_void: Result /= Void

	generator: STRING_8
			-- Name of current object's generating class
			-- (base class of the type of which it is a direct instance)
			-- (from ANY)
		ensure -- from ANY
			generator_not_void: Result /= Void
			generator_not_empty: not Result.is_empty

	has_edge (a_from, a_to: INTEGER_32): BOOLEAN
			-- Does graph contain edge from `a_from` to `a_to`?

	has_node (a_id: INTEGER_32): BOOLEAN
			-- Does graph contain node with `a_id`?

	is_directed: BOOLEAN
			-- Is this a directed graph?

	is_empty: BOOLEAN
			-- Is the graph empty?

	neighbors (a_id: INTEGER_32): ARRAYED_LIST [INTEGER_32]
			-- List of neighbor node IDs for `a_id`.
		require
			has_node: has_node (a_id)
		ensure
			all_neighbors_are_nodes: across
					Result as ic
				all
					has_node (ic)
				end

	node (a_id: INTEGER_32): detachable G
			-- Data for node with `a_id`.
		require
			has_node: has_node (a_id)

	node_count: INTEGER_32
			-- Number of nodes in graph.
	
feature -- Comparison

	frozen deep_equal (a: detachable ANY; b: like arg #1): BOOLEAN
			-- Are `a` and `b` either both void
			-- or attached to isomorphic object structures?
			-- (from ANY)
		ensure -- from ANY
			instance_free: class
			shallow_implies_deep: standard_equal (a, b) implies Result
			both_or_none_void: (a = Void) implies (Result = (b = Void))
			same_type: (Result and (a /= Void)) implies (b /= Void and then a.same_type (b))
			symmetric: Result implies deep_equal (b, a)

	frozen equal (a: detachable ANY; b: like arg #1): BOOLEAN
			-- Are `a` and `b` either both void or attached
			-- to objects considered equal?
			-- (from ANY)
		ensure -- from ANY
			instance_free: class
			definition: Result = (a = Void and b = Void) or else ((a /= Void and b /= Void) and then a.is_equal (b))

	frozen is_deep_equal alias "≡≡≡" (other: SIMPLE_GRAPH [G]): BOOLEAN
			-- Are `Current` and `other` attached to isomorphic object structures?
			-- (from ANY)
		require -- from ANY
			other_not_void: other /= Void
		ensure -- from ANY
			shallow_implies_deep: standard_is_equal (other) implies Result
			same_type: Result implies same_type (other)
			symmetric: Result implies other.is_deep_equal (Current)

	is_equal (other: SIMPLE_GRAPH [G]): BOOLEAN
			-- Is `other` attached to an object considered
			-- equal to current object?
			-- (from ANY)
		require -- from ANY
			other_not_void: other /= Void
		ensure -- from ANY
			symmetric: Result implies other ~ Current
			consistent: standard_is_equal (other) implies Result

	frozen standard_equal (a: detachable ANY; b: like arg #1): BOOLEAN
			-- Are `a` and `b` either both void or attached to
			-- field-by-field identical objects of the same type?
			-- Always uses default object comparison criterion.
			-- (from ANY)
		ensure -- from ANY
			instance_free: class
			definition: Result = (a = Void and b = Void) or else ((a /= Void and b /= Void) and then a.standard_is_equal (b))

	frozen standard_is_equal alias "≜" (other: SIMPLE_GRAPH [G]): BOOLEAN
			-- Is `other` attached to an object of the same type
			-- as current object, and field-by-field identical to it?
			-- (from ANY)
		require -- from ANY
			other_not_void: other /= Void
		ensure -- from ANY
			same_type: Result implies same_type (other)
			symmetric: Result implies other.standard_is_equal (Current)
	
feature -- Status report

	conforms_to (other: ANY): BOOLEAN
			-- Does type of current object conform to type
			-- of `other` (as per Eiffel: The Language, chapter 13)?
			-- (from ANY)
		require -- from ANY
			other_not_void: other /= Void

	same_type (other: ANY): BOOLEAN
			-- Is type of current object identical to type of `other`?
			-- (from ANY)
		require -- from ANY
			other_not_void: other /= Void
		ensure -- from ANY
			definition: Result = (conforms_to (other) and other.conforms_to (Current))
	
feature -- Element change

	add_edge (a_from, a_to: INTEGER_32)
			-- Add edge from `a_from` to `a_to` with weight 1.0.
		require
			from_exists: has_node (a_from)
			to_exists: has_node (a_to)
		ensure
			edge_exists: has_edge (a_from, a_to)
			nodes_unchanged: model_nodes |=| old model_nodes

	add_edge_weighted (a_from, a_to: INTEGER_32; a_weight: REAL_64)
			-- Add edge from `a_from` to `a_to` with `a_weight`.
		require
			from_exists: has_node (a_from)
			to_exists: has_node (a_to)
		ensure
			edge_exists: has_edge (a_from, a_to)
			reverse_for_undirected: not is_directed and a_from /= a_to implies has_edge (a_to, a_from)
			nodes_unchanged: model_nodes |=| old model_nodes

	add_node (a_data: G): INTEGER_32
			-- Add node with `a_data`, return node ID.
		ensure
			node_added: has_node (Result)
			count_increased: node_count = old node_count + 1
			model_extended: model_nodes |=| (old model_nodes & Result)
			edges_unchanged: model_edges |=| old model_edges

	add_node_with_id (a_id: INTEGER_32; a_data: G)
			-- Add node with specific `a_id` and `a_data`.
		require
			id_positive: a_id > 0
			no_existing: not has_node (a_id)
		ensure
			node_added: has_node (a_id)
			count_increased: node_count = old node_count + 1
			model_extended: model_nodes |=| (old model_nodes & a_id)
			edges_unchanged: model_edges |=| old model_edges

	clear
			-- Remove all nodes and edges.
		ensure
			empty: is_empty
			model_nodes_empty: model_nodes.is_empty
			model_edges_empty: model_edges.is_empty

	remove_edge (a_from, a_to: INTEGER_32)
			-- Remove edge from `a_from` to `a_to`.
		require
			has_edge: has_edge (a_from, a_to)
		ensure
			edge_removed: not has_edge (a_from, a_to)
			nodes_unchanged: model_nodes |=| old model_nodes

	remove_node (a_id: INTEGER_32)
			-- Remove node `a_id` and all its edges.
		require
			has_node: has_node (a_id)
		ensure
			node_removed: not has_node (a_id)
			count_decreased: node_count = old node_count - 1
			model_reduced: model_nodes |=| (old model_nodes / a_id)
			no_edges_involving_node: not model_edges.domain [a_id] and not model_edges.range [a_id]
	
feature -- Duplication

	copy (other: SIMPLE_GRAPH [G])
			-- Update current object using fields of object attached
			-- to `other`, so as to yield equal objects.
			-- (from ANY)
		require -- from ANY
			other_not_void: other /= Void
			type_identity: same_type (other)
		ensure -- from ANY
			is_equal: Current ~ other

	frozen deep_copy (other: SIMPLE_GRAPH [G])
			-- Effect equivalent to that of:
			--		`copy` (`other` . `deep_twin`)
			-- (from ANY)
		require -- from ANY
			other_not_void: other /= Void
		ensure -- from ANY
			deep_equal: deep_equal (Current, other)

	frozen deep_twin: SIMPLE_GRAPH [G]
			-- New object structure recursively duplicated from Current.
			-- (from ANY)
		ensure -- from ANY
			deep_twin_not_void: Result /= Void
			deep_equal: deep_equal (Current, Result)

	frozen standard_copy (other: SIMPLE_GRAPH [G])
			-- Copy every field of `other` onto corresponding field
			-- of current object.
			-- (from ANY)
		require -- from ANY
			other_not_void: other /= Void
			type_identity: same_type (other)
		ensure -- from ANY
			is_standard_equal: standard_is_equal (other)

	frozen standard_twin: SIMPLE_GRAPH [G]
			-- New object field-by-field identical to `other`.
			-- Always uses default copying semantics.
			-- (from ANY)
		ensure -- from ANY
			standard_twin_not_void: Result /= Void
			equal: standard_equal (Result, Current)

	frozen twin: SIMPLE_GRAPH [G]
			-- New object equal to `Current`
			-- `twin` calls `copy`; to change copying/twinning semantics, redefine `copy`.
			-- (from ANY)
		ensure -- from ANY
			twin_not_void: Result /= Void
			is_equal: Result ~ Current
	
feature -- Basic operations

	frozen default: detachable SIMPLE_GRAPH [G]
			-- Default value of object's type
			-- (from ANY)

	frozen default_pointer: POINTER
			-- Default value of type `POINTER`
			-- (Avoid the need to write `p`.`default` for
			-- some `p` of type `POINTER`.)
			-- (from ANY)
		ensure -- from ANY
			instance_free: class

	default_rescue
			-- Process exception for routines with no Rescue clause.
			-- (Default: do nothing.)
			-- (from ANY)

	frozen do_nothing
			-- Execute a null action.
			-- (from ANY)
		ensure -- from ANY
			instance_free: class
	
feature -- Analysis

	degree (a_id: INTEGER_32): INTEGER_32
			-- Number of edges connected to node `a_id`.
		require
			has_node: has_node (a_id)

	has_cycle: BOOLEAN
			-- Does the graph contain a cycle?

	in_degree (a_id: INTEGER_32): INTEGER_32
			-- Number of incoming edges to node `a_id` (directed graphs).
		require
			has_node: has_node (a_id)

	is_connected: BOOLEAN
			-- Is the graph connected? (all nodes reachable from any node)

	out_degree (a_id: INTEGER_32): INTEGER_32
			-- Number of outgoing edges from node `a_id` (directed graphs).
		require
			has_node: has_node (a_id)

	topological_sort: ARRAYED_LIST [INTEGER_32]
			-- Topological ordering of nodes (directed acyclic graph only).
			-- Returns empty list if graph has a cycle.
		require
			directed: is_directed
		ensure
			empty_if_cycle: has_cycle implies Result.is_empty
	
feature -- Model queries (specification support)

	model_adjacency: MML_MAP [INTEGER_32, MML_SET [INTEGER_32]]
			-- Map from each node to its set of neighbors.
		ensure
			domain_matches: Result.domain |=| model_nodes

	model_edges: MML_RELATION [INTEGER_32, INTEGER_32]
			-- Relation of edge pairs (from_node, to_node).
			-- For undirected graphs, each edge appears once (lower ID first).
		ensure
			count_matches: Result.count = edge_count

	model_nodes: MML_SET [INTEGER_32]
			-- Set of all node IDs in the graph.
		ensure
			count_matches: Result.count = node_count
			all_valid: Result.for_all (agent has_node)
	
feature -- Output

	Io: STD_FILES
			-- Handle to standard file setup
			-- (from ANY)
		ensure -- from ANY
			instance_free: class
			io_not_void: Result /= Void

	out: STRING_8
			-- New string containing terse printable representation
			-- of current object
			-- (from ANY)
		ensure -- from ANY
			out_not_void: Result /= Void

	print (o: detachable ANY)
			-- Write terse external representation of `o`
			-- on standard output.
			-- (from ANY)
		ensure -- from ANY
			instance_free: class

	frozen tagged_out: STRING_8
			-- New string containing terse printable representation
			-- of current object
			-- (from ANY)
		ensure -- from ANY
			tagged_out_not_void: Result /= Void
	
feature -- Platform

	Operating_environment: OPERATING_ENVIRONMENT
			-- Objects available from the operating system
			-- (from ANY)
		ensure -- from ANY
			instance_free: class
			operating_environment_not_void: Result /= Void
	
feature -- Shortest Path

	dijkstra (a_start, a_end: INTEGER_32): ARRAYED_LIST [INTEGER_32]
			-- Shortest path from `a_start` to `a_end` using Dijkstra's algorithm.
			-- Returns empty list if no path exists.
		require
			start_exists: has_node (a_start)
			end_exists: has_node (a_end)
		ensure
			empty_or_starts_at_start: Result.is_empty or else Result.first = a_start
			empty_or_ends_at_end: Result.is_empty or else Result.last = a_end

	shortest_distance (a_start, a_end: INTEGER_32): REAL_64
			-- Shortest distance from `a_start` to `a_end`.
			-- Returns -1 if no path exists.
		require
			start_exists: has_node (a_start)
			end_exists: has_node (a_end)
	
feature -- Traversal

	bfs (a_start: INTEGER_32): ARRAYED_LIST [INTEGER_32]
			-- Breadth-first traversal starting from `a_start`.
		require
			has_node: has_node (a_start)
		ensure
			starts_with_start: not Result.is_empty implies Result.first = a_start

	dfs (a_start: INTEGER_32): ARRAYED_LIST [INTEGER_32]
			-- Depth-first traversal starting from `a_start`.
		require
			has_node: has_node (a_start)
		ensure
			starts_with_start: not Result.is_empty implies Result.first = a_start
	
invariant
	valid_next_id: next_id >= 1
	edges_valid: model_edges.domain <= model_nodes and model_edges.range <= model_nodes
	adjacency_consistent: model_adjacency.domain |=| model_nodes

		-- from ANY
	reflexive_equality: standard_is_equal (Current)
	reflexive_conformance: conforms_to (Current)

end -- class SIMPLE_GRAPH

